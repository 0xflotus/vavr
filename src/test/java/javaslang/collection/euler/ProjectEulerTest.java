/*     / \____  _    ______   _____ / \____   ____  _____
 *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
 *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
 * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection.euler;

import javaslang.Function1;
import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.collection.List;
import javaslang.collection.Stream;
import javaslang.control.Match;
import org.junit.Test;

import java.util.function.Function;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * <p>Contains high-level tests of the collection package.</p>
 * <p>See also <a href="https://projecteuler.net">Project Euler</a> and Pavel Fatin's
 * <a href="https://pavelfatin.com/ninety-nine">ninety-nine</a>.</p>
 */
public class ProjectEulerTest {

    /**
     * <strong>Problem 1: Multiples of 3 and 5</strong>
     * <p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
     * The sum of these multiples is 23.</p>
     * <p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
     * <p>See also <a href="https://projecteuler.net/problem=1">projecteuler.net problem 1</a>.</p>
     */
    @Test
    public void shouldSolveProblem1() {
        assertThat(sumOfMultiplesOf3and5Below(10)).isEqualTo(23);
        assertThat(sumOfMultiplesOf3and5Below(1000)).isEqualTo(233168);
    }

    private static int sumOfMultiplesOf3and5Below(int limit) {
        return List.range(0, limit).filter(ProjectEulerTest::isMultipleOf3or5).sum().intValue();
    }

    private static boolean isMultipleOf3or5(int num) {
        return num != 0 && (num % 3 == 0 || num % 5 == 0);
    }

    /**
     * <strong>Problem 2: Even Fibonacci numbers</strong>
     * <p>Each new term in the Fibonacci sequence is generated by adding the previous
     * two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5,
     * 8, 13, 21, 34, 55, 89, ...</p>
     * <p>By considering the terms in the Fibonacci sequence whose values do not exceed
     * four million, find the sum of the even-valued terms.</p>
     * <p>See also <a href="https://projecteuler.net/problem=2">projecteuler.net problem 2</a>.</p>
     */
    @Test
    public void shouldSolveProblem2() {
        assertThat(sumOfEvenFibonacciValuesNotExceeding(90)).isEqualTo(2 + 8 + 34);
        assertThat(sumOfEvenFibonacciValuesNotExceeding(4_000_000)).isEqualTo(4_613_732);
    }

    private static long sumOfEvenFibonacciValuesNotExceeding(final int max) {
        return Stream.from(2)
                .map(memoizedFibonacci)
                .takeWhile(f -> f <= max)
                .filter(f -> f % 2 == 0)
                .sum().longValue();
    }

    private static final Function<Integer, Long> memoizedFibonacci = Function1.lift(ProjectEulerTest::fibonacci).memoized();

    private static long fibonacci(int order) {
        return Match
                .when(0).then(() -> 0L)
                .whenIn(1, 2).then(() -> 1L)
                .otherwise(() -> memoizedFibonacci.apply(order - 2) + memoizedFibonacci.apply(order - 1))
                .apply(order);
    }

    /**
     * <strong>Problem 3: Largest prime factor</strong>
     * The prime factors of 13195 are 5, 7, 13 and 29.
     * <p>
     * What is the largest prime factor of the number 600851475143?
     * <p>
     * See also <a href="https://projecteuler.net/problem=3">projecteuler.net problem 3</a>.
     */
    @Test
    public void shouldSolveProblem3() {
        assertThat(largestPrimeFactorOf(24)).isEqualTo(3);
        assertThat(largestPrimeFactorOf(29)).isEqualTo(29);
        assertThat(largestPrimeFactorOf(13195)).isEqualTo(29);
        assertThat(largestPrimeFactorOf(600_851_475_143L)).isEqualTo(6857);
    }

    private static long largestPrimeFactorOf(long val) {
        final Tuple2<Long, Long> head = new Tuple2<>(1L, val);
        return Stream.gen(head, () -> primeFactorsAndResultingValTail(head))
                .map(t -> t._1)
                .reduce(Math::max);
    }

    private static Stream<Tuple2<Long, Long>> primeFactorsAndResultingValTail(Tuple2<Long, Long> previousFactorAndResultingVal) {
        return Match
                .when(1L).then(() -> Stream.<Tuple2<Long, Long>>nil())
                .otherwise(() -> {
                    final long nextPrimeFactor = knownPrimes.filter(p -> previousFactorAndResultingVal._2 % p == 0).take(1).head();
                    final Tuple2<Long, Long> head = new Tuple2<>(nextPrimeFactor, previousFactorAndResultingVal._2 / nextPrimeFactor);
                    return Stream.gen(head, () -> primeFactorsAndResultingValTail(head));
                })
                .apply(previousFactorAndResultingVal._2);
    }

    /**
     * <strong>Problem 4: Largest palindrome product</strong>
     * A palindromic number reads the same both ways. The largest palindrome made
     * from the product of two 2-digit numbers is 9009 = 91 × 99.
     * <p>
     * Find the largest palindrome made from the product of two 3-digit numbers.
     * <p>
     * See also <a href="https://projecteuler.net/problem=4">projecteuler.net problem 4</a>.
     */
    @Test
    public void shouldSolveProblem4() {
        assertThat(largestPalindromeOfProductsFromFactorsInRange(10, 99)).isEqualTo(9009);
        assertThat(largestPalindromeOfProductsFromFactorsInRange(100, 999)).isEqualTo(906609);
    }

    private static int largestPalindromeOfProductsFromFactorsInRange(final int min, final int max) {
        return Stream.rangeClosed(min, max)
                .flatMap(i -> Stream.rangeClosed(i, max).map(j -> i * j))
                .filter(ProjectEulerTest::isPalindrome)
                .max().get();
    }

    private static boolean isPalindrome(int val) {
        final String valAsString = Long.toString(val);
        return valAsString.equals(reverse(valAsString));
    }

    private static String reverse(String s) {
        return new StringBuilder(s).reverse().toString();
    }

    /**
     * <strong>Problem 5: Smallest multiple</strong>
     * 2520 is the smallest number that can be divided by each of the numbers from 1
     * to 10 without any remainder.
     * <p>
     * What is the smallest positive number that is evenly divisible by all of the
     * numbers from 1 to 20?
     * <p>
     * See also <a href="https://projecteuler.net/problem=5">projecteuler.net problem 5</a>.
     */
    @Test
    public void shouldSolveProblem5() {
        assertThat(smallestPositiveNumberEvenlyDivisibleByAllNumbersFrom1To(10)).isEqualTo(2_520L);
        assertThat(smallestPositiveNumberEvenlyDivisibleByAllNumbersFrom1To(20)).isEqualTo(232_792_560L);
    }

    private static long smallestPositiveNumberEvenlyDivisibleByAllNumbersFrom1To(int max) {
        final long smallestStepsNeeded = max * (max - 1);
        return Stream.gen(smallestStepsNeeded, prev -> prev + smallestStepsNeeded)
                .findFirst(val -> isEvenlyDivisibleByAllNumbersFrom1To(max, val))
                .get();
    }

    private static boolean isEvenlyDivisibleByAllNumbersFrom1To(int max, long val) {
        return !Stream.rangeClosed(1, max).exists(d -> val % d != 0);
    }

    /**
     * <strong>Problem 6: Sum square difference</strong>
     * The sum of the squares of the first ten natural numbers is,
     * <p>
     * 1² + 2² + ... + 10² = 385
     * <p>
     * The square of the sum of the first ten natural
     * numbers is,
     * <p>
     * (1 + 2 + ... + 10)² = 55² = 3025
     * <p>
     * Hence the difference between the sum of the
     * squares of the first ten natural numbers and the square of the sum is
     * <p>
     * 3025 − 385 = 2640.
     * <p>
     * Find the difference between the sum of the squares of the first one hundred
     * natural numbers and the square of the sum.
     * <p>
     * See also <a href="https://projecteuler.net/problem=6">projecteuler.net problem 6</a>.
     */
    @Test
    public void shouldSolveProblem6() {
        assertThat(differenceBetweenSumOfTheSquaresAndSquareOfTheSumFrom1UpTo(10)).isEqualTo(2640L);
        assertThat(differenceBetweenSumOfTheSquaresAndSquareOfTheSumFrom1UpTo(100)).isEqualTo(25164150L);
    }

    private static long differenceBetweenSumOfTheSquaresAndSquareOfTheSumFrom1UpTo(int max) {
        return squareOfSumFrom1UpTo(max) - sumOfSquaresFrom1UpTo(max);
    }

    private static long squareOfSumFrom1UpTo(int max) {
        return (long) Math.pow(Stream.rangeClosed(1, max).sum().longValue(), 2);
    }

    private static long sumOfSquaresFrom1UpTo(int max) {
        return Stream.rangeClosed(1, max)
                .map(i -> (long) Math.pow(i, 2))
                .sum().longValue();
    }

    /**
     * <strong>Problem 7: 10001st prime</strong>
     * <p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>
     * <p>What is the 10 001st prime number?</p>
     * <p>See also <a href="https://projecteuler.net/problem=7">projecteuler.net problem 7</a>.</p>
     */
    @Test
    public void shouldSolveProblem7() {
        assertThat(primeNo(1)).isEqualTo(2);
        assertThat(primeNo(2)).isEqualTo(3);
        assertThat(primeNo(3)).isEqualTo(5);
        assertThat(primeNo(4)).isEqualTo(7);
        assertThat(primeNo(5)).isEqualTo(11);
        assertThat(primeNo(6)).isEqualTo(13);
        assertThat(primeNo(10_001)).isEqualTo(104_743);
    }

    private static long primeNo(int index) {
        if (index < 1) {
            throw new IllegalArgumentException("index < 1");
        }
        return knownPrimes.get(index - 1);
    }

    private static final Stream<Long> knownPrimes = Stream.gen(2L, ProjectEulerTest::nextPrime);

    private static long nextPrime(long previousPrime) {
        return Match
                .when(2L).then(() -> 3L)
                .otherwise(() -> Stream.gen(previousPrime + 2, v -> v + 2)
                        .filter(i -> !isEvenlyDiversableByKnownPrimes(previousPrime, i))
                        .take(1).head())
                .apply(previousPrime);
    }

    private static boolean isEvenlyDiversableByKnownPrimes(long previousPrime, long val) {
        return knownPrimes.takeWhile(p -> p < previousPrime).append(previousPrime)
                .exists(p -> val % p == 0);
    }

    /**
     * <strong>Problem 71: Ordered fractions</strong>
     * <p>Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.</p>
     * <p>If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:</p>
     * <p>1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8</p>
     * <p>It can be seen that 2/5 is the fraction immediately to the left of 3/7.</p>
     * <p>By listing the set of reduced proper fractions for d ≤ 1,000,000 in ascending order of size, find the numerator of the fraction immediately to the left of 3/7.</p>
     * <p>See also <a href="https://projecteuler.net/problem=71">projecteuler.net problem 71</a>.</p>
     */
    @Test
    public void shouldSolveProblem71() {
        assertThat(left37(8)).isEqualTo(2);
        assertThat(left37(1_000_000)).isEqualTo(428_570);
    }

    private static int left37(int maxDenominator) {
        return Stream
                .gen(Tuple.of(0, 1, 1, 1), t -> {
                    int m1 = t._1 + t._3;
                    int m2 = t._2 + t._4;
                    if (m1 * 7 >= m2 * 3) {
                        return Tuple.of(t._1, t._2, m1, m2);
                    } else {
                        return Tuple.of(m1, m2, t._3, t._4);
                    }
                })
                .takeWhile(t -> t._2 <= maxDenominator && t._4 <= maxDenominator)
                .reverse()
                .head()
                ._1;
    }
}
